## useEffectフックとは
useEffectは、コンポーネントがレンダリングされた後に副作用（サイドエフェクト）を実行するためにReactによって提供されるフックです。
副作用とは、データの取得、購読の設定解除、手動でのDOMの変更など、コンポーネントのレンダリング結果に影響を与える操作のことを指します。
デフォルトでは、useEffect内の副作用はコンポーネントの各レンダリング後に実行されますが、これは常に望ましい振る舞いではありません。

## 依存配列
useEffectフックに依存配列を第2引数として渡すことで、副作用の実行タイミングを細かく制御できます。
依存配列内の値（ステートやプロップ）が変更された場合にのみ、副作用が再実行されるようになります。
これにより、不必要な副作用の実行を防ぎ、アプリケーションのパフォーマンスを向上させることができます。

## 依存配列の正しい使用
副作用内で参照されるすべてのステートやプロップは、依存配列に含める必要があります。
副作用がこれらの値に「依存している」ためで、値の変更を正確に追跡することが重要です。
依存配列を正しく設定しないと、「陳腐したクロージャー」によるバグや、予期しない動作の原因となる場合があります。

※ 依存配列にオブジェクトを入れる場合
JSのオブジェクトは再作成されるたびに異なる参照を持ちます。
よって、再レンダリング前後でオブジェクトが変わっていなくても、Reactはeffectを実行します。
useEffectに限らず、依存関数を持つ全ての関数も同様です。

## 依存配列から不要な依存関係を取り除く方法
- 依存配列にある関数をeffectの中に移動する
  複数の場所で同じ関数が必要になる場合effectの中に入れられないので、はuseCallbackでメモ化する。
  関数がリアクティブでない場合は、コンポーネント外に定義する。
- オブジェクト全体ではなく必要なプロパティのみを依存配列に入れる
  プロパティがプリミティブである限り可能。

### 依存配列の異なるパターン
- 複数の依存関係: 
  複数の値に依存する場合、それらを依存配列に含めることで、いずれかの値が変更された際に副作用が再実行されます。
- 空の依存配列: 
  配列を空にすると、副作用はコンポーネントのマウント時にのみ実行され、アンマウント時にクリーンアップされます。APIからデータを一度だけ取得する場合などに有用です。
- 依存配列なし: 
  依存配列を省略した場合、副作用はコンポーネントの各レンダリング後に実行されます。これは副作用がレンダリングに密接に関連している場合に適していますが、パフォーマンスの観点から避けるべきです。

## クリーンアップ関数
useEffectフック内で返される関数は、クリーンアップ関数として機能します。
この関数は、エフェクトが再実行される前やコンポーネントがアンマウントされる際に実行され、副作用の後始末を行います。

以下のコンポーネントでは、コンポーネントがマウントされた際にページのタイトルを更新し、アンマウント時に元のタイトルに戻します。
```
import { useEffect } from 'react';

function PageTitleUpdater({ title }) {
  useEffect(() => {
    // ページタイトルを更新
    const originalTitle = document.title;
    document.title = title;

    // クリーンアップ関数で元のタイトルに戻す
    return () => {
      document.title = originalTitle;
    };
  }, [title]); // タイトルが変更された時のみエフェクトを再実行

  return <h1>{title}</h1>;
}
```

### クリーンアップ関数が必要なタイミング
クリーンアップ関数が特に必要となるタイミングは、コンポーネントのライフサイクル中に発生する特定の状況において、副作用が継続的に影響を与える可能性がある場合です。
これは、副作用がコンポーネントの再レンダリングやアンマウント後も続く場合に特に重要となります。
以下は、クリーンアップ関数が必要とされる具体的なシナリオの例です：

#### HTTPリクエストのキャンセル
コンポーネント内でHTTPリクエストを行い、そのリクエストが完了する前にコンポーネントが再レンダリングされたりアンマウントされたりした場合、未処理のリクエストが予期せぬ副作用を引き起こす可能性があります。
例えば、リクエストが完了した際にコンポーネントの状態を更新しようとすると、コンポーネントがもはや存在しないためにエラーが発生する可能性があります。
これを防ぐために、クリーンアップ関数内で進行中のリクエストをキャンセルします。
```
useEffect(() => {
  const request = fetch('https://example.com/api');

  return () => {
    // リクエストが完了する前にコンポーネントがアンマウントされた場合は、
    // リクエストをキャンセルする
    if (request && request.abort) {
      request.abort();
    }
  };
}, []);
```

#### APIサービスの購読解除
外部APIサービスへの購読を開始した場合、コンポーネントがアンマウントされた後も購読が継続されると、不要なデータのフェッチやメモリリークが発生する可能性があります。
クリーンアップ関数を使用して購読を解除し、これらの問題を防ぎます。
```
useEffect(() => {
  const subscription = api.subscribe(data => {
    // データ更新処理
  });

  return () => {
    // コンポーネントがアンマウントされた時に購読を解除する
    subscription.unsubscribe();
  };
}, []);
```

#### タイマーの停止
setTimeout や setInterval によってタイマーを設定した場合、コンポーネントがアンマウントされる前にタイマーをクリア（停止）することが重要です。
これにより、タイマーのコールバックがコンポーネントの状態を更新しようとするときに、存在しないコンポーネントにアクセスしてエラーが発生するのを防ぎます。
```
useEffect(() => {
  const timer = setTimeout(() => {
    // タイマー処理
  }, 1000);

  return () => {
    // コンポーネントがアンマウントされた時にタイマーをクリアする
    clearTimeout(timer);
  };
}, []);
```

#### イベントリスナーの削除
コンポーネントがイベントリスナーを追加した場合、コンポーネントのアンマウント時にこれらのリスナーを削除することが必要です。
そうしないと、削除されたコンポーネントに関連するイベントが引き続き発生し、不要な処理が行われることになります。
```
useEffect(() => {
  const element = document.getElementById('my-element');

  element.addEventListener('click', () => {
    // イベント処理
  });

  return () => {
    // コンポーネントがアンマウントされた時にイベントリスナーを削除する
    element.removeEventListener('click', () => {
      // イベント処理
    });
  };
}, []);
```

### クリーンアップ関数の実行タイミング
- エフェクトの再実行前：
  依存配列内の値が変更されると、前のエフェクトのクリーンアップが実行された後に新しいエフェクトが実行されます。
- コンポーネントのアンマウント時：
  コンポーネントがアンマウントされる際に、エフェクトのクリーンアップが実行されます。
