## はじめに
ReactのuseEffectフックと依存配列についての理解は、効率的なコンポーネントの動作とパフォーマンスの最適化に不可欠です。
この技術は、コンポーネントがどのようにして外部のリソースやAPIと同期し、更新を管理するかを把握する上で中心的な役割を担います。
本記事では、useEffectフックの動作原理、依存配列の役割、そしてその使用方法について詳しく解説します。

## useEffectフックとは
useEffectは、コンポーネントがレンダリングされた後に副作用（サイドエフェクト）を実行するためにReactによって提供されるフックです。
副作用とは、データの取得、購読の設定解除、手動でのDOMの変更など、コンポーネントのレンダリング結果に影響を与える操作のことを指します。
デフォルトでは、useEffect内の副作用はコンポーネントの各レンダリング後に実行されますが、これは常に望ましい振る舞いではありません。

## 依存配列とその効果
useEffectフックに依存配列を第2引数として渡すことで、副作用の実行タイミングを細かく制御できます。
依存配列内の値（ステートやプロップ）が変更された場合にのみ、副作用が再実行されるようになります。
これにより、不必要な副作用の実行を防ぎ、アプリケーションのパフォーマンスを向上させることができます。

## 依存配列の正しい使用
副作用内で参照されるすべてのステートやプロップは、依存配列に含める必要があります。
副作用がこれらの値に「依存している」ためで、値の変更を正確に追跡することが重要です。
依存配列を正しく設定しないと、「陳腐したクロージャー」によるバグや、予期しない動作の原因となる場合があります。

### 依存配列の異なるパターン
- 複数の依存関係: 複数の値に依存する場合、それらを依存配列に含めることで、いずれかの値が変更された際に副作用が再実行されます。
- 空の依存配列: 配列を空にすると、副作用はコンポーネントのマウント時にのみ実行され、アンマウント時にクリーンアップされます。APIからデータを一度だけ取得する場合などに有用です。
- 依存配列なし: 依存配列を省略した場合、副作用はコンポーネントの各レンダリング後に実行されます。これは副作用がレンダリングに密接に関連している場合に適していますが、パフォーマンスの観点から避けるべきです。

## クリーンアップ関数
useEffectフック内で返される関数は、クリーンアップ関数として機能します。
この関数は、エフェクトが再実行される前やコンポーネントがアンマウントされる際に実行され、副作用の後始末を行います。

以下のコンポーネントでは、コンポーネントがマウントされた際にページのタイトルを更新し、アンマウント時に元のタイトルに戻します。
```
import { useEffect } from 'react';

function PageTitleUpdater({ title }) {
  useEffect(() => {
    // ページタイトルを更新
    const originalTitle = document.title;
    document.title = title;

    // クリーンアップ関数で元のタイトルに戻す
    return () => {
      document.title = originalTitle;
    };
  }, [title]); // タイトルが変更された時のみエフェクトを再実行

  return <h1>{title}</h1>;
}
```

### クリーンアップ関数の実行タイミング
- エフェクトの再実行前：依存配列内の値が変更されると、前のエフェクトのクリーンアップが実行された後に新しいエフェクトが実行されます。
- コンポーネントのアンマウント時：コンポーネントがアンマウントされる際に、エフェクトのクリーンアップが実行されます。


## まとめ
useEffectフックと依存配列の正しい理解と使用は、Reactアプリケーションの効率的な動作と最適なパフォーマンスを実現するために欠かせません。
依存配列を通じて副作用の実行タイミングを細かく制御することで、不必要な処理を減らし、アプリケーションの応答性を高めることができます。
